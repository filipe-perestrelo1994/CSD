-- Net Garagem - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity Garagem IS
Port(
    Clk : IN STD_LOGIC;
    arrive : IN STD_LOGIC;
    got_ticket : IN STD_LOGIC;
    exit : IN STD_LOGIC;
    payment : IN STD_LOGIC;
    gate_in_open : OUT STD_LOGIC;
    get_out_open : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End Garagem;

Architecture Structural OF Garagem IS

    Signal p_2: INTEGER RANGE 0 TO 3 := 0;
    Signal p_3: INTEGER RANGE 0 TO 3 := 1;
    Signal p_6: INTEGER RANGE 0 TO 3 := 0;
    Signal p_8: INTEGER RANGE 0 TO 3 := 3;
    Signal p_9: INTEGER RANGE 0 TO 3 := 0;
    Signal p_11: INTEGER RANGE 0 TO 3 := 0;
    Signal p_12: INTEGER RANGE 0 TO 3 := 0;
    Signal p_14: INTEGER RANGE 0 TO 3 := 1;


    Signal s_gate_in_open : STD_LOGIC := '0';
    Signal s_get_out_open : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
        End If;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_2_add, p_2_avail : INTEGER RANGE 0 to 3;
      Variable p_3_add, p_3_avail : INTEGER RANGE 0 to 3;
      Variable p_6_add, p_6_avail : INTEGER RANGE 0 to 3;
      Variable p_8_add, p_8_avail : INTEGER RANGE 0 to 3;
      Variable p_9_add, p_9_avail : INTEGER RANGE 0 to 3;
      Variable p_11_add, p_11_avail : INTEGER RANGE 0 to 3;
      Variable p_12_add, p_12_avail : INTEGER RANGE 0 to 3;
      Variable p_14_add, p_14_avail : INTEGER RANGE 0 to 3;
    Begin
      If Reset = '1' Then
          p_2 <= 0;
          p_3 <= 1;
          p_6 <= 0;
          p_8 <= 3;
          p_9 <= 0;
          p_11 <= 0;
          p_12 <= 0;
          p_14 <= 1;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_2_avail := p_2;
          p_2_add := 0;   -- P_Wait_Ticket;
          p_3_avail := p_3;
          p_3_add := 0;   -- P_In_Free;
          p_6_avail := p_6;
          p_6_add := 0;   -- P_Gate_In_Down;
          p_8_avail := p_8;
          p_8_add := 0;   -- P_Free_Places;
          p_9_avail := p_9;
          p_9_add := 0;   -- P_Occupied_Places;
          p_11_avail := p_11;
          p_11_add := 0;   -- P_Gate_Out_Open;
          p_12_avail := p_12;
          p_12_add := 0;   -- P_Wait_Payment;
          p_14_avail := p_14;
          p_14_add := 0;   -- P_Out_Free;


          -- Transition 4 - T_Arrive_Up
          If (p_3_avail >= 1) and 
             (conv_integer(arrive) = 1) -- guard expr 
          Then
              p_3_avail := p_3_avail - 1;    -- P_In_Free
              p_2_add := p_2_add + 1;   -- P_Wait_Ticket
          End If;

          -- Transition 5 - T_Got_Ticket
          If (p_2_avail >= 1) and
             (p_8_avail >= 1) and 
             (conv_integer(got_ticket) = 1) -- guard expr 
          Then
              p_2_avail := p_2_avail - 1;    -- P_Wait_Ticket
              p_8_avail := p_8_avail - 1;    -- P_Free_Places
              p_6_add := p_6_add + 1;   -- P_Gate_In_Down
              p_9_add := p_9_add + 1;   -- P_Occupied_Places
          End If;

          -- Transition 7 - T_Arrive_Down
          If (p_6_avail >= 1)
          Then
              p_6_avail := p_6_avail - 1;    -- P_Gate_In_Down
              p_3_add := p_3_add + 1;   -- P_In_Free
          End If;

          -- Transition 10 - T_Got_Payment
          If (p_9_avail >= 1) and
             (p_12_avail >= 1) and 
             (conv_integer(payment) = 1) -- guard expr 
          Then
              p_9_avail := p_9_avail - 1;    -- P_Occupied_Places
              p_12_avail := p_12_avail - 1;    -- P_Wait_Payment
              p_8_add := p_8_add + 1;   -- P_Free_Places
              p_11_add := p_11_add + 1;   -- P_Gate_Out_Open
          End If;

          -- Transition 13 - T_Exit_Up
          If (p_14_avail >= 1) and 
             (conv_integer(exit) = 1) -- guard expr 
          Then
              p_14_avail := p_14_avail - 1;    -- P_Out_Free
              p_12_add := p_12_add + 1;   -- P_Wait_Payment
          End If;

          -- Transition 15 - T_Exit_Down
          If (p_11_avail >= 1)
          Then
              p_11_avail := p_11_avail - 1;    -- P_Gate_Out_Open
              p_14_add := p_14_add + 1;   -- P_Out_Free
          End If;

          -- Calculate final place marking:
          p_2 <= p_2_avail + p_2_add;
          p_3 <= p_3_avail + p_3_add;
          p_6 <= p_6_avail + p_6_add;
          p_8 <= p_8_avail + p_8_add;
          p_9 <= p_9_avail + p_9_add;
          p_11 <= p_11_avail + p_11_add;
          p_12 <= p_12_avail + p_12_add;
          p_14 <= p_14_avail + p_14_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_gate_in_open <= '0';
          s_get_out_open <= '0';

        Elsif Enable='1' Then

          -- Signal gate_in_open default value:
          new_value := 0;

          -- gate_in_open action on place P_Gate_In_Down(p_6)
          If p_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store gate_in_open and check result range:
          If new_value < 0 Then s_gate_in_open <= '0';
            Elsif new_value > 1 Then s_gate_in_open <= '1';
            Else s_gate_in_open <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal get_out_open default value:
          new_value := 0;

          -- get_out_open action on place P_Gate_Out_Open(p_11)
          If p_11 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store get_out_open and check result range:
          If new_value < 0 Then s_get_out_open <= '0';
            Elsif new_value > 1 Then s_get_out_open <= '1';
            Else s_get_out_open <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    gate_in_open <= s_gate_in_open;
    get_out_open <= s_get_out_open;

End Structural;
